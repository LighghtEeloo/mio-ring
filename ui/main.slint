enum State { rect-plain, rect-drag, rect-hold }
struct Area2D {
    x: length,
    y: length,
    width: length,
    height: length,
}

component Captured inherits Image {
    property <State> state;
    // point in maybe form
    property <[Point]> point-a;
    // another point in maybe form
    property <[Point]> point-b;

    function is-valid() -> bool {
        state != State.rect-plain && point-a.length != 0 && point-b.length != 0
    }
    in property <color> mask-color: #c1c6d4;

    // the selected area in maybe form
    out property <[Area2D]> area;

    // input: two points on xy plane
    // modifies: anchor & frame
    callback compute-anchor-frame();
    compute-anchor-frame() => {
        if (!(point-a.length == 0 || point-b.length == 0)) {
            root.area = [{
                x: min(point-a[0].x, point-b[0].x),
                y: min(point-a[0].y, point-b[0].y),
                width: abs((point-a[0].x - point-b[0].x) / 1px) * 1px,
                height: abs((point-a[0].y - point-b[0].y) / 1px) * 1px
            }];
        }
    }

    callback start-drag;
    start-drag => {
        state = State.rect-drag;
        point-a = [{ x: area.mouse-x, y: area.mouse-y }];
        point-b = [];
    }

    callback end-drag;
    end-drag => {
        state = State.rect-hold;
        point-b = [{ x: area.mouse-x, y: area.mouse-y }];
    }

    function check-pointer(e: PointerEvent, button: PointerEventButton, kind: PointerEventKind) -> bool {
        e.button == button && e.kind == kind
    }

    area := TouchArea {
        pointer-event(e) => {
            if (state == State.rect-plain && check-pointer(e, PointerEventButton.left, PointerEventKind.down)) {
                start-drag();
            } else if (state == State.rect-drag && check-pointer(e, PointerEventButton.left, PointerEventKind.up)) {
                end-drag();
            } else if (state == State.rect-hold && check-pointer(e, PointerEventButton.left, PointerEventKind.down)) {
                start-drag();
            }
            compute-anchor-frame();
        }
        moved => {
            point-b = [{ x: area.mouse-x, y: area.mouse-y }];
            compute-anchor-frame();
        }
    }

    out property <[Area2D]> mask-areas: [ {
        x: 0, y: 0,
        width: root.area[0].x, height: root.height
    }, {
        x: root.area[0].x, y: 0,
        width: root.area[0].width, height: root.area[0].y 
    }, {
        x: root.area[0].x, y: root.area[0].y + root.area[0].height,
        width: root.area[0].width, height: root.height
    }, {
        x: root.area[0].x + root.area[0].width, y: 0,
        width: root.width, height: root.height
    } ];

    // four rectangles as masks
    for mask[i] in mask-areas: Rectangle {
        visible: is-valid();
        background: mask-color;
        opacity: 0.5;
        x: mask.x;
        y: mask.y;
        width: mask.width;
        height: mask.height;
    }

    // one fallback mask
    Rectangle {
        visible: !is-valid();
        background: mask-color;
        opacity: 0.5;
        x: 0;
        y: 0;
        width: 100%;
        height: 100%;
    }

    callback commit(bool, Area2D);
    in property <length> pic_width;
    in property <length> pic_height;

    // receive keyboard events
    focused := FocusScope {
        key-pressed(e) => {
            if (e.text == Key.Return) {
                if (e.modifiers.shift) {
                    commit(true, {
                        x: 0, y: 0,
                        width: 0, height: 0
                    })
                } else {
                    commit(false, {
                        x: root.area[0].x * pic_width / root.width,
                        y: root.area[0].y * pic_height / root.height,
                        width: root.area[0].width * pic_width / root.width,
                        height: root.area[0].height * pic_height / root.height
                    })
                }
            }
            accept
        }
    }

    init => {
        focused.focus();
    }
}

export component MainWindow inherits Window {
    title: "~ Mio Ring ~";
    // no-frame: true;

    in property <image> raw-shot;
    in property <length> pic_width <=> cap.pic_width;
    in property <length> pic_height <=> cap.pic_height;
    callback commit(bool, Area2D);

    cap := Captured {
        source: raw-shot;
        height: 100%;
        commit(is-full, area) => { root.commit(is-full, area); }
    }
}