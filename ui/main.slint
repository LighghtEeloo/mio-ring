enum State { rect-plain, rect-drag, rect-hold }
struct Area2D {
    x: length,
    y: length,
    width: length,
    height: length,
}

component Captured inherits Image {
    width: 100%;
    height: 100%;

    property <State> state;
    // point in maybe form
    property <[Point]> point-a;
    // another point in maybe form
    property <[Point]> point-b;

    function is-valid() -> bool {
        state != State.rect-plain && point-a.length != 0 && point-b.length != 0
    }
    in property <color> mask-color: #c1c6d4;

    // the top-left point in maybe form
    out property <[Point]> anchor;
    // the width and height in maybe form
    out property <[Point]> frame;

    // utils
    function pointed(p: [Point]) -> Point {
        p.length == 0 ? { x: 0, y: 0 } : p[0]
    }
    function check-pointer(e: PointerEvent, button: PointerEventButton, kind: PointerEventKind) -> bool {
        e.button == button && e.kind == kind
    }

    // input: two points on xy plane
    // modifies: anchor & frame
    callback compute-anchor-frame();
    compute-anchor-frame() => {
        if (!(point-a.length == 0 || point-b.length == 0)) {
            anchor = [{
                x: min(point-a[0].x, point-b[0].x),
                y: min(point-a[0].y, point-b[0].y)
            }];
            frame = [{
                x: abs((point-a[0].x - point-b[0].x) / 1px) * 1px,
                y: abs((point-a[0].y - point-b[0].y) / 1px) * 1px
            }];
        }
    }

    callback start-drag;
    start-drag => {
        state = State.rect-drag;
        point-a = [{ x: area.mouse-x, y: area.mouse-y }];
        point-b = [];
    }

    callback end-drag;
    end-drag => {
        state = State.rect-hold;
        point-b = [{ x: area.mouse-x, y: area.mouse-y }];
    }

    area := TouchArea {
        pointer-event(e) => {
            if (state == State.rect-plain && check-pointer(e, PointerEventButton.left, PointerEventKind.down)) {
                start-drag();
            } else if (state == State.rect-drag && check-pointer(e, PointerEventButton.left, PointerEventKind.up)) {
                end-drag();
            } else if (state == State.rect-hold && check-pointer(e, PointerEventButton.left, PointerEventKind.down)) {
                start-drag();
            }
            compute-anchor-frame();
        }
        moved => {
            point-b = [{ x: area.mouse-x, y: area.mouse-y }];
            compute-anchor-frame();
        }
    }

    out property <[Area2D]> mask-areas: [ {
        x: 0, y: 0,
        width: pointed(anchor).x, height: root.height
    }, {
        x: pointed(anchor).x, y: 0,
        width: pointed(frame).x, height: pointed(anchor).y 
    }, {
        x: pointed(anchor).x, y: pointed(anchor).y + pointed(frame).y,
        width: pointed(frame).x, height: root.height
    }, {
        x: pointed(anchor).x + pointed(frame).x, y: 0,
        width: root.width, height: root.height
    } ];

    // four rectangles as masks
    for mask[i] in mask-areas: Rectangle {
        visible: is-valid();
        background: mask-color;
        opacity: 0.5;
        x: mask.x;
        y: mask.y;
        width: mask.width;
        height: mask.height;
    }

    // one fallback mask
    Rectangle {
        visible: !is-valid();
        background: mask-color;
        opacity: 0.5;
        x: 0;
        y: 0;
        width: 100%;
        height: 100%;
    }

    callback commit(bool, Area2D);

    // receive keyboard events
    FocusScope {
        key-pressed(e) => {
            // debug(e.text);
            // if (e.modifiers.control) {
            //     debug("control was pressed during this event");
            // }
            if (e.text == Key.Return) {
                debug("Return key was pressed");
                commit(false, {
                    x: pointed(anchor).x, y: pointed(anchor).y,
                    width: pointed(frame).x, height: pointed(frame).y
                })
            }
            accept
        }
    }
}

export component MainWindow inherits Window {
    title: "~ Mio Ring ~";
    // no-frame: true;
    in property <image> raw-shot;
    callback commit(bool, Area2D);
    cap := Captured {
        source: raw-shot;
        commit(is-full, area) => { root.commit(is-full, area); }
    }
}