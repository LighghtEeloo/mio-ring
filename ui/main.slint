enum State { rect-plain, rect-drag, rect-hold }
struct Area2D {
    x: length,
    y: length,
    width: length,
    height: length,
}

component HollowMask {
    in property <Area2D> selected;
    in property <color> mask-color: #c1c6d4;

    private property <[Area2D]> mask-areas: [
        {
            x: 0, y: 0,
            width: selected.x, height: root.height
        }, {
            x: selected.x - 0.01px, y: 0,
            width: selected.width + 0.02px, height: selected.y 
        }, {
            x: selected.x - 0.01px, y: selected.y + selected.height,
            width: selected.width + 0.02px, height: root.height - selected.y - selected.height
        }, {
            x: selected.x + selected.width, y: 0,
            width: root.width - selected.x - selected.width, height: root.height
        }
    ];

    // four rectangles as masks
    for mask[i] in mask-areas: Rectangle {
        visible: root.visible;
        background: mask-color;
        opacity: root.opacity;
        x: mask.x;
        y: mask.y;
        width: mask.width;
        height: mask.height;
    }

}

component Resizer inherits Rectangle {
    in property <length> size: 8px;
    background: #d9e0e6;
    border-color: #3a3a3a;
    border-width: 1px;
    // in property <length> a;
    // in property <length> b;
}

component SelectedRect {
    in property <Area2D> selected;
    width: 100%;
    height: 100%;

    // main frame
    Rectangle {
        visible: root.visible;
        background: #00000000;
        border-color: #c0d4f5;
        border-width: 2px;
        x: selected.x;
        y: selected.y;
        width: selected.width;
        height: selected.height;
    }

    // eight resizers
    private property <[Point]> positions: [
        { x: selected.x, y: selected.y },
        { x: selected.x + selected.width / 2, y: selected.y },
        { x: selected.x + selected.width, y: selected.y },
        { x: selected.x, y: selected.y + selected.height / 2 },
        { x: selected.x + selected.width, y: selected.y + selected.height / 2 },
        { x: selected.x, y: selected.y + selected.height },
        { x: selected.x + selected.width / 2, y: selected.y + selected.height },
        { x: selected.x + selected.width, y: selected.y + selected.height },
    ];

    for position[i] in positions: Resizer {
        visible: root.visible;
        x: position.x - self.size / 2;
        y: position.y - self.size / 2;
        width: self.size;
        height: self.size;
        // a: self.b;
        // b: self.a;
    }
}

component Captured inherits Image {
    property <State> state;
    // point in maybe form
    private property <[Point]> point-a;
    // another point in maybe form
    private property <[Point]> point-b;
    // the selected area in maybe form
    out property <[Area2D]> selected;

    function current-pointer-position() -> Point {
        { x: area.mouse-x, y: area.mouse-y }
    }

    // input: two points on xy plane
    // modifies: selected
    callback compute-selected();
    compute-selected() => {
        if (!(point-a.length == 0 || point-b.length == 0)) {
            selected = [{
                x: min(point-a[0].x, point-b[0].x),
                y: min(point-a[0].y, point-b[0].y),
                width: abs((point-a[0].x - point-b[0].x) / 1px) * 1px,
                height: abs((point-a[0].y - point-b[0].y) / 1px) * 1px
            }];
        }
    }

    callback start-drag;
    start-drag => {
        state = State.rect-drag;
        point-a = [current-pointer-position()];
        point-b = [current-pointer-position()];
    }

    callback end-drag;
    end-drag => {
        state = State.rect-hold;
        point-b = [current-pointer-position()];
    }

    function check-pointer(e: PointerEvent, button: PointerEventButton, kind: PointerEventKind) -> bool {
        e.button == button && e.kind == kind
    }

    area := TouchArea {
        pointer-event(e) => {
            if (state == State.rect-plain && check-pointer(e, PointerEventButton.left, PointerEventKind.down)) {
                start-drag();
            } else if (state == State.rect-drag && check-pointer(e, PointerEventButton.left, PointerEventKind.up)) {
                end-drag();
            } else if (state == State.rect-hold && check-pointer(e, PointerEventButton.left, PointerEventKind.down)) {
                start-drag();
            } else if (check-pointer(e, PointerEventButton.right, PointerEventKind.up)) {
                exit();
            }
            compute-selected();
        }
        moved => {
            point-b = [current-pointer-position()];
            compute-selected();
        }
    }

    in property <color> mask-color: #c1c6d4;

    HollowMask {
        visible: state == State.rect-drag || state == State.rect-hold;
        mask-color: mask-color;
        opacity: 0.5;
        selected: selected[0];
        width: 100%;
        height: 100%;
    }

    // // fallback mask
    // Rectangle {
    //     visible: state == State.rect-plain;
    //     background: mask-color;
    //     opacity: 0.5;
    //     x: 0;
    //     y: 0;
    //     width: 100%;
    //     height: 100%;
    // }

    SelectedRect {
        visible: state == State.rect-drag || state == State.rect-hold;
        selected: selected[0];
    }

    callback commit(bool, Area2D);
    in property <length> pic_width;
    in property <length> pic_height;
    callback exit();

    // receive keyboard events
    focuser := FocusScope {
        key-pressed(e) => {
            if (e.text == Key.Return) {
                if (e.modifiers.shift) {
                    commit(true, {
                        x: 0, y: 0,
                        width: 0, height: 0
                    })
                } else {
                    commit(false, {
                        x: selected[0].x * pic_width / root.width,
                        y: selected[0].y * pic_height / root.height,
                        width: selected[0].width * pic_width / root.width,
                        height: selected[0].height * pic_height / root.height
                    })
                }
            } else
            if (e.text == Key.Escape) {
                exit();
            }
            accept
        }
    }

    init => {
        focuser.focus();
    }
}

export component MainWindow inherits Window {
    title: "~ Mio Ring ~";
    no-frame: true;

    in property <image> raw-shot;
    in property <length> pic_width <=> cap.pic_width;
    in property <length> pic_height <=> cap.pic_height;
    callback commit(bool, Area2D);
    callback exit();

    cap := Captured {
        source: raw-shot;
        height: 100%;
        commit(is-full, area) => { root.commit(is-full, area); }
        exit() => { exit(); }
    }
}