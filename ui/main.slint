enum State { rect-plain, rect-drag, rect-hold }
struct Area2D {
    x: length,
    y: length,
    width: length,
    height: length,
}

component HollowMask {
    in property <Area2D> selected;
    in property <color> mask-color: #c1c6d4;

    private property <[Area2D]> mask-areas: [ {
        x: 0, y: 0,
        width: root.width, height: selected.y
    }, {
        x: 0, y: selected.y,
        width: selected.x, height: selected.height
    }, {
        x: selected.x + selected.width, y: selected.y,
        width: root.width - selected.x - selected.width, height: selected.height
    }, {
        x: 0, y: selected.y + selected.height,
        width: root.width, height: root.height - selected.y - selected.height
    } ];

    // four rectangles as masks
    for mask[i] in mask-areas: Rectangle {
        visible: root.visible;
        background: mask-color;
        opacity: root.opacity;
        x: mask.x;
        y: mask.y;
        width: mask.width;
        height: mask.height;
    }

}

component Captured inherits Image {
    property <State> state;
    // point in maybe form
    private property <[Point]> point-a;
    // another point in maybe form
    private property <[Point]> point-b;
    // the selected area in maybe form
    out property <[Area2D]> selected;

    function current-pointer-position() -> Point {
        { x: area.mouse-x, y: area.mouse-y }
    }

    // input: two points on xy plane
    // modifies: anchor & frame
    callback compute-anchor-frame();
    compute-anchor-frame() => {
        if (!(point-a.length == 0 || point-b.length == 0)) {
            selected = [{
                x: min(point-a[0].x, point-b[0].x),
                y: min(point-a[0].y, point-b[0].y),
                width: abs((point-a[0].x - point-b[0].x) / 1px) * 1px,
                height: abs((point-a[0].y - point-b[0].y) / 1px) * 1px
            }];
        }
    }

    callback start-drag;
    start-drag => {
        state = State.rect-drag;
        point-a = [current-pointer-position()];
        point-b = [current-pointer-position()];
    }

    callback end-drag;
    end-drag => {
        state = State.rect-hold;
        point-b = [current-pointer-position()];
    }

    function check-pointer(e: PointerEvent, button: PointerEventButton, kind: PointerEventKind) -> bool {
        e.button == button && e.kind == kind
    }

    area := TouchArea {
        pointer-event(e) => {
            if (state == State.rect-plain && check-pointer(e, PointerEventButton.left, PointerEventKind.down)) {
                start-drag();
            } else if (state == State.rect-drag && check-pointer(e, PointerEventButton.left, PointerEventKind.up)) {
                end-drag();
            } else if (state == State.rect-hold && check-pointer(e, PointerEventButton.left, PointerEventKind.down)) {
                start-drag();
            }
            compute-anchor-frame();
        }
        moved => {
            point-b = [current-pointer-position()];
            compute-anchor-frame();
        }
    }

    in property <color> mask-color: #c1c6d4;

    HollowMask {
        visible: state == State.rect-drag || state == State.rect-hold;
        mask-color: mask-color;
        opacity: 0.5;
        selected: selected[0];
        width: 100%;
        height: 100%;
    }

    // one fallback mask
    Rectangle {
        visible: state == State.rect-plain;
        background: mask-color;
        opacity: 0.5;
        x: 0;
        y: 0;
        width: 100%;
        height: 100%;
    }

    callback commit(bool, Area2D);
    in property <length> pic_width;
    in property <length> pic_height;

    // receive keyboard events
    focused := FocusScope {
        key-pressed(e) => {
            if (e.text == Key.Return) {
                if (e.modifiers.shift) {
                    commit(true, {
                        x: 0, y: 0,
                        width: 0, height: 0
                    })
                } else {
                    commit(false, {
                        x: selected[0].x * pic_width / root.width,
                        y: selected[0].y * pic_height / root.height,
                        width: selected[0].width * pic_width / root.width,
                        height: selected[0].height * pic_height / root.height
                    })
                }
            }
            accept
        }
    }

    init => {
        focused.focus();
    }
}

export component MainWindow inherits Window {
    title: "~ Mio Ring ~";
    // no-frame: true;

    in property <image> raw-shot;
    in property <length> pic_width <=> cap.pic_width;
    in property <length> pic_height <=> cap.pic_height;
    callback commit(bool, Area2D);

    cap := Captured {
        source: raw-shot;
        height: 100%;
        commit(is-full, area) => { root.commit(is-full, area); }
    }
}